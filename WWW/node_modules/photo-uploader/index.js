var http     = require('http');
var https    = require('https');
var fs       = require('fs');
var url      = require('url');
var path     = require('path');
var validURL = require('valid-url');
var rawBody  = require('raw-body');

// Using raw-body because the combined use of middleware bodyParser and transformerProxy
// cause req.url changes to be ignored. E.g. If string /auth.marktplaats.nl/ is removed
// from path, it magically returns when the request is made.
// Offending line: app.use(bodyParser.urlencoded({extended:true}));

"use strict";

module.exports = PhotoUploader;

/* HTTP request header fields */
var USER_AGENT      = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36';
var HOST            = 'www.marktplaats.nl';
var REFERER         = 'https://www.marktplaats.nl/syi/1/2/plaatsAdvertentie.html?bucket=1&origin=HEADER';
var CONTENT_TYPE    = 'multipart/form-data';
var ACCEPT          = '*/*';
var ACCEPT_ENCODING = 'gzip,deflate';
var ACCEPT_LANGUAGE = 'en-US,en;q=0.8,nl;q=0.6';
var CONNECTION      = 'Closed';

/* Upload url */
var TARGET_HOST     = 'www.marktplaats.nl';
var TARGET_PATH     = '/syi/uploadImage.json?nl.marktplaats.xsrf.token=';

function PhotoUploader(req) {
    this.request     = req;
    this.guidCounter = 0;
}

PhotoUploader.prototype.upload = function() {

    var _this = this;

    getOptionsFromBody(this, function(options) {

        _this.fullPath    = options.picturePath;
        _this.xsrfToken   = options.xsrfToken;
        _this.mpSessionID = options.mpSessionID;

        fetchPictureAndSend(_this);
    });
}

function getOptionsFromBody(_this, callback) {

    var rawBodyOptions = {
        length   :  _this.request.headers['content-length'],
        limit    : '1mb',
        encoding : 'utf8'
    };

    var httpBody = "";

    rawBody(_this.request, rawBodyOptions, function (err, string) {
        if (err) throw err;
        try {
            httpBody = JSON.parse(string);
        }
        catch(jsonError) {
            errorHandler(_this, { 'error' : 'PhotoUploader received damaged JSON object: '+jsonError.message});
        }
        callback(httpBody);
    });
}

function fetchPictureAndSend(_this) {

    // Grab image located on external site
    if (validURL.isWebUri(_this.fullPath)) {

        var parsedURL = url.parse(_this.fullPath);

        if (parsedURL.search!==null)
            parsedURL.path += parsedURL.search;

        var options = {
              host     : parsedURL.host,
              path     : parsedURL.path
        };

        var callback = function(res) {

              var dataBuffer = new Buffer(0);

              res.on('data', function (chunk) {
                  dataBuffer = Buffer.concat([dataBuffer, chunk]);
              });

              res.on('end', function () {
                  simulatePluploadSendRequest(_this, dataBuffer);
              });
        }

        var req = null;

        if (parsedURL.protocol==="https:") {
            req = https.request(options, callback);
        }
        else {
            req = http.request(options, callback);
        }

        req.on('error', function (err, req, res) {
            errorHandler(_this, { 'error' : 'Error downloading picture: '+err.message});
        });

        req.end();
    }
    else {
        // Grab image from local filesystem
        fs.readFile(_this.fullPath, function(err, dataBuffer) {
            if (err) {
                if (err.code==='ENOENT') {
                    errorHandler(_this, { 'error' : 'Bestand niet gevonden: '+_this.fullPath});
                }
                else throw err;
            }
            else simulatePluploadSendRequest(_this, dataBuffer);
        });
    }
}

function errorHandler(_this, error) {
    _this.request.emit("photoUploaderResult", JSON.stringify(error));
}

function getRequestHeader(guid, mpSessionID, contentLength) {
    return {
        'Host'            : HOST, 
        'Connection'      : CONNECTION, 
        'Origin'          : 'https://' + HOST, 
        'User-Agent'      : USER_AGENT,
        'Content-Type'    : CONTENT_TYPE+'; '+'boundary=----pluploadboundary'+guid,
        'Accept'          : ACCEPT,
        'Referer'         : REFERER,
/*        'Accept-Encoding' : ACCEPT_ENCODING,*/
        'Accept-Language' : ACCEPT_LANGUAGE,
        'Cookie'          : 'MpSession=' + mpSessionID + ';',
        'Content-Length'  : contentLength
    };
}

/**
 * Generates an unique ID.
 *
 * Based on: Moxiecode    https://github.com/moxiecode/moxie/blob/master/src/javascript/core/utils/Basic.js:guid()
 *           Plupload     https://github.com/moxiecode/plupload/blob/master/js/moxie.js:guid()
 *           Redmine_dmsf https://code.google.com/p/redmine-dmsf/source/browse/trunk/redmine_dmsf/assets/javascripts/plupload/plupload.js:guid()
 *
 * @method guid
 * @return {String} Virtually unique id.
 */

function getGuid(_this) {
    var guid = new Date().getTime().toString(32), i;
    for (i = 0; i < 5; i++) {
            guid += Math.floor(Math.random() * 65535).toString(32);
    }
    return 'p' + guid + (_this.guidCounter++).toString(32);
}

function simulatePluploadSendRequest(_this, fileData) {

    if (fileData!==null) {

        var guid     = getGuid(_this);
        var filename = path.basename(_this.fullPath);

        var messageBodyHeader = "";
        var messageBodyFooter = "";

        messageBodyHeader += '------pluploadboundary'+guid+"\r\n";
        messageBodyHeader += 'Content-Disposition: form-data; name="name"'+"\r\n";
        messageBodyHeader += "\r\n";
        messageBodyHeader += filename+"\r\n";
        messageBodyHeader += '------pluploadboundary'+guid+"\r\n";
        messageBodyHeader += 'Content-Disposition: form-data; name="imageData"; filename="'+filename+'"'+"\r\n";
        messageBodyHeader += 'Content-Type: image/jpeg'+"\r\n\r\n";
        messageBodyFooter += "\r\n"+'------pluploadboundary'+guid+"--\r\n";

        var messageBodyHeaderBuffer = new Buffer(messageBodyHeader);
        var messageBodyImageBuffer  = new Buffer(fileData);
        var messageBodyFooterBuffer = new Buffer(messageBodyFooter);
        var messageBodyBuffer       = Buffer.concat([messageBodyHeaderBuffer, messageBodyImageBuffer, messageBodyFooterBuffer]);

        // An object of options to indicate where to post to
        var postOptions = {
            method  : 'POST',
            host    : TARGET_HOST,
            //port    : 88,
            path    : TARGET_PATH + _this.xsrfToken,
            headers : getRequestHeader(guid, _this.mpSessionID, messageBodyBuffer.length)
        };

        // Set up the request
        var post_req = https.request(postOptions, function(res) {

              var dataBuffer = "";
              res.setEncoding('ascii');

              res.on('data', function (chunk) {
                  dataBuffer += chunk;
              });

              res.on('end', function () {
                  _this.request.emit("photoUploaderResult", dataBuffer);
              });

              res.on('error', function (err, req, res) {
                  errorHandler(_this, { 'error' : 'Error sending pictures: '+err.message});
              });
        });

        post_req.on('error', function (err) {
            switch(err.code) {
                case 'ECONNREFUSED':
                    errorHandler(_this, { 'error' : 'Error: [PhotoUploader] Connection to server '+TARGET_HOST+' refused.'});
                    break;
                default:
                    console.log("Unhandled exception occurred, stack trace:\n");
                    console.log(err.stack);
                    break;
            }
        });

        // post the data
        post_req.write(messageBodyBuffer);
        post_req.end();
    }
}

